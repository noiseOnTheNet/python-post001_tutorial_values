#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
#+CATEGORY: Language learning
#+TAGS: Python
#+DESCRIPTION: how to use basic containers
#+title: Python Tutorial: Basic data structures


*  Lists and Tuples (and Strings, again)
**  List literals
list can be constructed with the square parens; they can hold objects
of different kinds and even lists; all objects are separated by a comma
#+begin_src python
[] # an empty list
["hi"] # a list with just one element
[1,"ho!",[3.5, (0+1j)]] # a nested list with multiple elements
#+end_src
**  List access
list elements can be accessed via the square brackets operator.

List indices are 0-based, i.e. the first element has index 0, the second has
index 1 etc.

Lists can be accessed backward with negative indices

When the index exceed the list size an error is generated
#+begin_src python :eval never
["hi", "mom"][1] # returns "mom"
["thanks", "for", "all", "the", "fish"][-2] # returns "the"
[][1] # throws an exception
#+end_src
**  Splices
In order to show some result, starting from this paragraph I will use the
~print~ function. A more detailed description of functions will be presented
later.

When applied to lists, the square bracket operator accepts splices, returning
sublists.

A splice has two possible forms
- start : stop
- start : stop : step

Where start, stop and step are integers.

The first represent the first index to be taken, the second the first excluded
index and the step represent the periodicity of the extraction

All three elements are optional, when missing
- start will point to the beginning of the string
- end will point to the end of the string
- step will be 1

Negative steps are allowed: switching the meaning of start and stop
#+begin_src python :eval never-export :results output :exports both
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][1:4])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][1:6:2])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][:4])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][4::2])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][-3:9:2])
#+end_src

#+RESULTS:
: ['quick', 'brown', 'fox']
: ['quick', 'fox', 'over']
: ['the', 'quick', 'brown', 'fox']
: ['jumps', 'the', 'dog']
: ['the', 'dog']

**  Accessing strings with index and splice
index and splice work in the very same way with strings as they do with lists

#+begin_src python :eval never-export :results output :exports both
print("abcdefghijklmno"[5])
print("abcdefghijklmno"[-3])
print("abcdefghijklmno"[:4])
print("abcdefghijklmno"[-5:])
print("abcdefghijklmno"[2:8:2])
#+end_src

#+RESULTS:
: f
: m
: abcd
: klmno
: ceg

**  Tuple literals
Tuple can contain ordered sequences of various kinds of objects, as list do

Tuple literal constructor is the comma, but as the empty tuple is represented by
an empty parens () usually parens are always used in tuple literals for better readability

Indices and tuples also apply as in lists; the main difference with list is
related to mutability, a theme I will explain later.

#+begin_src python :eval never-export :results output :exports both
print((True,"hi",3.14159,0+1j)[-1])
print((True,"hi",3.14159,0+1j)[2])
print((True,"hi",3.14159,0+1j)[:3])
#+end_src

#+RESULTS:
: 1j
: 3.14159
: (True, 'hi', 3.14159)

**  Operators on lists and tuples
as we already saw with strings the + operator concatenates lists and tuples with
similar containers (i.e. tuples can't be concatenated with lists and vice versa)

The * operator with an integer repeats the content of the sequence

#+begin_src python :eval never-export :results output :exports both
print(["This", "is", "not"] + ["America"])
print(("hi", "ho") * 3)
#+end_src

#+RESULTS:
: ['This', 'is', 'not', 'America']
: ('hi', 'ho', 'hi', 'ho', 'hi', 'ho')

**  String formatting with modulo and tuples
the modulo operator accepts a string on the left side and a tuple or a list on
the right side.

the result is equivalent to the c "sprintf" function: the string content will be
interpolated with the content of the sequence; placeholders begin with a % sign
and use a letter code to define the expected type of datum. Here is an incomplete list

| sequence | data type                    |
|----------+------------------------------|
| %s       | any object                   |
| %d       | integers                     |
| %f       | numbers (fixed point format) |
| %e       | numbers (scientific format)  |

Between the % sign and the letter some combination of digits and symbols can
modify the output; here are some example: please refer to a printf manual for
more details

#+begin_src python :eval never-export :results output :exports both
print("|%10s| and |%-10s| space padding" % ("positive", "negative"))
print("fixed point %.4f and scientific %.4e modifiers" % (3.14159, 3.14159 / 1000))
#+end_src

#+RESULTS:
: |  positive| and |negative  | space padding
: fixed point 3.1416 and scientific 3.1416e-03 modifiers

*  Dictionaries and Sets (and more Strings)
**  Set iterals
Sets are containers which behave as math sets:
- they contain just one copy of each value
- it is possible to efficiently test if a value belongs to the sets
more operations on set will be described later

Set literal constructor is the curl brace.

#+begin_src python :eval never-export :results output :exports both
{} # an empty set
{"Hi"} # a set with only one item
print({2,2,3,1,"Joe"}) # duplicate item in literals will be dropped
#+end_src

#+RESULTS:
: {1, 2, 3, 'Joe'}

lists are not allowed to be set values while tuples are. This is related to
their immutability as we will see later
**  Dictionary literals
dictionaries or maps associate keys with values.

As their literal constructor is a list of key-value pairs; each pair is divided
by a colon and the list is surrounded by curl braces

As with other containers there is no restriction to use different types of
objects in the same container.

Lists are not valid keys while tuples are (as with set contents).

#+begin_src python :eval never-export :results output :exports both
{"hello":1, 10:True, (1,2,3,4):3.14159}
#+end_src
**  Dictionary access
to retrieve a value from a dictionary, its key can be passed through the square
bracket operator

#+begin_src python :eval never-export :results output :exports both
print({"hello":1, 10:True, (1,2,3,4):3.14159}["hello"])
#+end_src

#+RESULTS:
: 1

if the selected key is missing an error is generated
**  Set and dictionary operators
the ~in~ operator can check if an element is part of a set or if there is a key
in a dictionary

#+begin_src python :eval never-export :results output :exports both
print(2 in {10, "Joe", 2})
print(2 in {"hello":1, 10:True, (1,2,3,4):3.14159})
#+end_src

#+RESULTS:
: True
: False

while this operator also works on tuples and lists its time complexity is linear
while it is constant on dictionaries and sets, so it is not recommended to use
it with them.
**  String formatting with modulo and dictionaries
Dictionaries can be used as the right operand in string formatting expressions
with the modulo operator.

This can be useful when
- formatting strings with many data without worrying about order
- rusing the same value multiple times

placeholders modifiers will include key names in parens
#+begin_src python :eval never-export :results output :exports both
print("on %(date)s the temperature is %(temperature).2f degrees" % {"temperature":2.3, "date":"Monday, January 1st"})
print("My name is %(surname)s, %(first name)s %(surname)s" % {"first name":"James", "surname":"Bond"})
#+end_src

#+RESULTS:
: on Monday, January 1st the temperature is 2.30 degrees
: My name is Bond, James Bond
