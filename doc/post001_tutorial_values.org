#+BLOG: noise on the net
#+POSTID: 149
#+DATE: [2022-11-20 dom 20:06]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
#+CATEGORY: Language learning
#+TAGS: Python
#+DESCRIPTION: how are values created in the source code of python, how to create basic expressions and use basic containers
#+title: Python tutorial: literals, values, operators and expressions

https:/noise/wp-content/uploads/2023/08/david-clode-5uU8HSpfwkI-unsplash-2-scaled.jpg

Photo by [[https://unsplash.com/@davidclode?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText][David Clode]] on [[https://unsplash.com/photos/5uU8HSpfwkI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText][Unsplash]]


This post is the first of a series; I'd like to share some python knowledge
starting from very basic information and avoiding forward references as much as
possible.

As python evolves I'll try to keep up with latest updates, I'll be treating
python 3 only. This post was started on Saturday, November 19th 2022.

I reccommend to use the basic python interactive command line to really have an
immediate feedback of what python actually does.

Of course there are more convenient interactive environments, but all of them
introduce some complexity which makes it difficult to have a clear mental model
of the language
*  Installing
There are two main ways I reccommend to install python
- from the python site https://www.python.org/
  - python basic package manager is ~pip~ you can use it from any command line of your operative system
  - when using base python I recommend to create independent [[https://docs.python.org/3/library/venv.html][virtual
    environments]] for each project, this will help you keep track of the packages
    you are using and also avoid issues with multiple package versions; the
    following commands refer to a linux bash command line, you can find windows
    equivalent in the [[https://docs.python.org/3/library/venv.html#creating-virtual-environments][virtual environment documentation]]
    1. install venv with the following command
        #+begin_src bash :noeval
pip install venv
        #+end_src
    2. create a project directory and change your current directory into it
        #+begin_src bash :noeval
    mkdir myproject
    cd myproject
        #+end_src
    3. create a virtual environment in the project directory
        #+begin_src bash :noeval
    python -m venv .
        #+end_src
    4. activate it
        #+begin_src bash :noeval
    source bin/activate
        #+end_src
- using the miniconda from Continuum https://docs.conda.io/en/latest/miniconda.html
  - this package and environment manager allows you to easily create independent
    projects, keeping separate package environments as well as using separate
    python interpreters
  - when using Miniconda I also recommend to create separate environments for
    each project and avoid using the ~base~ environment which hosts the package
    manager itself
    1. create a virtual environment with the python version of your choice
        #+begin_src bash :noeval
    conda create -n myenv python=3.10
        #+end_src
    2. create your project directory and move into it
    3. activate your conda environment
        #+begin_src bash :noeval
conda activate myenv
        #+end_src
*  Using the interactive command line (REPL)
Python provides a basic interactive command line to start with, I recommend to
play with it and possibly with all of its extensions.

The command line reads the python expressions or statements, evaluates or
executes them respectively and prints the result; these interactive command
lines are called also Read, Eval, Print Loops (REPL) and were available since
the LISP language.

to start the python REPL open your command line, move into your project,
activate it and typ
#+begin_src bash :noeval
python
#+end_src

this will print some version information and the basic python prompt ~>>>~

you can type here python expressions and also whole programs (which is not the
most convenient way); it also provide you with a very fast feedback.

In time many extensions to the python CLI where developed which have some
advantages, here is a list of some:
- ipython
- ptipython (which adds some CLI and editing functionalities)
- jupyter notebook (web powered extension)
- jupyter lab (even more powerful)
*  Numbers
the python interpreter reads the code and translate it into bytecode -- a lower
level language which is then executed.

This translation process consists in reading code text and create data
structures which represents data objects and actions to be performed in memory

Data can be read from formats which are called literals: there can be different
ways to represent the same object.

Here we will go through some of the numeric formats and their object representation

Try to type these literals into the CLI and python will return a "canonical"
representation of the equivalent numeric object
**  Integers
integer values can be represented in multiple ways:
#+begin_src python :noeval
# decimal
1000000
# decimal with underscore for readability
1_000_000
# hexadecimal
0xAA19
# binary
0b1001010
# octal
0o675
#+end_src

**  Floats
floating point values can be represented with floating point or scientific format
#+begin_src python
# floating point
-123.4
# scientific
-1.234e2
#+end_src
**  Complex
python supports complex numbers literals with cartesian representation
#+begin_src python
(1*2j)
# also floating point can be used in the cartesian format
(1.0+2.0j)
#+end_src
** Operator and expressions on numbers
ordinary infix operators are available for all numeric types, with the ordinary
precedence rules.

Precedence can be adjusted by means of parethesis as usual.

#+begin_src python
(2 + 3) * 4 # 20
3 / 4 # 0.75 promoted to float
3 // 4 # 0 integer division
3 ** 4 # 81 integer power
(2+3j) * (2-3j) # 25 complex product
#+end_src

for integer numbers also binary operators are useful:

#+begin_src python
0b1001 | 0b0101 # yields 0b1101 or 13
0b1001 & 0b1001 # yields 0b0001 or 1
0b1001 ^ 0b0101 # yields 0b1100 or 12
~ 0b0101 # yields 0b1010 or 10
#+end_src

integer numbers also have modulo operator
#+begin_src python
13 % 4 # yields 1
#+end_src
** Basic functions
*  Strings
Strings are data sequances mostly used for human readable text; python strings
are of two kind:
1. Unicode text strings: each readable character can be represented by one or more bytes
2. Binary strings: each character will be represented by exactly one bytes,
   non-readable bytes by escaped hexadecimal sequences of two digits
**  Text strings
string literals are surrounded by single quotes ~'~ or double quotes ~"~
#+begin_src python
"hi mom"
'hi mom'
#+end_src
when the python REPL returns the canonical representation it uses only the
single quote
**  Triple quote
text in a string can be surrounded by triple quotes ~"""~ or ~'''~, this allows
to introduce multiline string literals
#+begin_src pyton
"""hi
mom"""
#+end_src
when typing multiline expressions the CLI prompt switch to ~...~
**  Escaping and Unicode
text strings include special characters which were used to control text
representation: e.g. newline (ASCII 10) and carriage return (ASCII 13).

These characters are represented by a backward slash ~\~ followed by
1. a character e.g. newline is ~\n~ and carriage return is ~\r~
2. a three digit octal number representing an ASCII character e.g. ~\012~
3. a two digit hexadecimal number e.g. ~\x0A~
4. an unicode number below 0x10000 ~\u000A~, → ~\u2192~
5. a 32 bit unicode number ~\U0000000A~, → ~\U00002192~
6. a unicode name ~"\N{RIGHTWARDS ARROW}"~

some printable character may require escape:
1. the forward slash itself ~\\~
2. quotes when identical with the surrounding quotes ~\'~ and ~\"~

See more details also [[https://en.wikipedia.org/wiki/Escape_sequences_in_C][here]]
**  Raw strings
by prefixing the letter ~r~ to the first quote, escaping characters will be
ignored and treated literally: these are called raw strings

Forward slash appear in a couple of situation:
1. in windows paths (here I will suggest better options later) e.g. ~c:\TEMP~
2. in regular expressions character classes e.g. ~\d~ the class of digit
   characters

In this case raw strings can be helpful
**  Binary strings
By prefixing a quote with the ~b~ letter the string will be interpreted as a
binary sequence.

This is useful when
- reading or writing to an external device, possibly connected through a serial
- reading or writing binary files

e.g. the following 4 bytes are the "magic number" at the beginning of java class
file format
#+begin_src python
b"\xCA\xFE\xBA\xBE"
#+end_src
**  Operators on strings
strings can use sum and multiplication as following
#+begin_src python
"hello " + "world" # yields hello world
"hello " * 3 # yields "hello hello hello "
#+end_src

I will introduce more operators and activities on strings later
*  Booleans and None
there are a couple of predefined data types with a limited number of values
which play a fundamental role in python
**  None
the None type contains just the ~None~ value

This can be seen as an equivalent of a NULL pointer, its actual usage will be
shown later
**  Boolean values and operators
Boolean type has exactly two values, boolean shortcut operators are written as
words and have the usual precedence rules
#+begin_src python
True
False
True and False
True or False
not True
#+end_src
**  Triple operator and truth values
the triple operator is composed of
- the value to be returned if the clause is true
- the boolean clause
- the value to be returned if the clause is false
#+begin_src python
"there is sunshine" if True else "it rains" # returns "there is sunshine"
-1 if False else 42 # yields 42
#+end_src

the clause may contain also non boolean values (a deprecated practice)

In python the following objects are false
| 0    | integer or floating point number 0 |
| None | the None object                    |
| ""   | the empty string                   |

I will add more falsy values later. In contrast the following objects are
considered "True"

|    1 | any integer, float or complex number different from 0 |
| "hi" | any non-empty string                                  |

I don't recommend using this way to evaluate clauses as they may be less
readable.
*  Lists and Tuples (and Strings, again)
**  List literals
list can be constructed with the square parens; they can hold objects
of different kinds and even lists; all objects are separated by a comma
#+begin_src python
[] # an empty list
["hi"] # a list with just one element
[1,"ho!",[3.5, (0+1j)]] # a nested list with multiple elements
#+end_src
**  List access
list elements can be accessed via the square brackets operator.

List indices are 0-based, i.e. the first element has index 0, the second has
index 1 etc.

Lists can be accessed backward with negative indices

When the index exceed the list size an error is generated
#+begin_src python :eval never
["hi", "mom"][1] # returns "mom"
["thanks", "for", "all", "the", "fish"][-2] # returns "the"
[][1] # throws an exception
#+end_src
**  Splices
In order to show some result, starting from this paragraph I will use the
~print~ function. A more detailed description of functions will be presented
later.

When applied to lists, the square bracket operator accepts splices, returning
sublists.

A splice has two possible forms
- start : stop
- start : stop : step

Where start, stop and step are integers.

The first represent the first index to be taken, the second the first excluded
index and the step represent the periodicity of the extraction

All three elements are optional, when missing
- start will point to the beginning of the string
- end will point to the end of the string
- step will be 1

Negative steps are allowed: switching the meaning of start and stop
#+begin_src python :eval never-export :results output :exports both
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][1:4])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][1:6:2])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][:4])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][4::2])
print(["the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog"][-3:9:2])
#+end_src

#+RESULTS:
: ['quick', 'brown', 'fox']
: ['quick', 'fox', 'over']
: ['the', 'quick', 'brown', 'fox']
: ['jumps', 'the', 'dog']
: ['the', 'dog']

**  Accessing strings with index and splice
index and splice work in the very same way with strings as they do with lists

#+begin_src python :eval never-export :results output :exports both
print("abcdefghijklmno"[5])
print("abcdefghijklmno"[-3])
print("abcdefghijklmno"[:4])
print("abcdefghijklmno"[-5:])
print("abcdefghijklmno"[2:8:2])
#+end_src

#+RESULTS:
: f
: m
: abcd
: klmno
: ceg

**  Tuple literals
Tuple can contain ordered sequences of various kinds of objects, as list do

Tuple literal constructor is the comma, but as the empty tuple is represented by
an empty parens () usually parens are always used in tuple literals for better readability

Indices and tuples also apply as in lists; the main difference with list is
related to mutability, a theme I will explain later.

#+begin_src python :eval never-export :results output :exports both
print((True,"hi",3.14159,0+1j)[-1])
print((True,"hi",3.14159,0+1j)[2])
print((True,"hi",3.14159,0+1j)[:3])
#+end_src

#+RESULTS:
: 1j
: 3.14159
: (True, 'hi', 3.14159)

**  Operators on lists and tuples
as we already saw with strings the + operator concatenates lists and tuples with
similar containers (i.e. tuples can't be concatenated with lists and vice versa)

The * operator with an integer repeats the content of the sequence

#+begin_src python :eval never-export :results output :exports both
print(["This", "is", "not"] + ["America"])
print(("hi", "ho") * 3)
#+end_src

#+RESULTS:
: ['This', 'is', 'not', 'America']
: ('hi', 'ho', 'hi', 'ho', 'hi', 'ho')

**  String formatting with modulo and tuples
the modulo operator accepts a string on the left side and a tuple or a list on
the right side.

the result is equivalent to the c "sprintf" function: the string content will be
interpolated with the content of the sequence; placeholders begin with a % sign
and use a letter code to define the expected type of datum. Here is an incomplete list

| sequence | data type                    |
|----------+------------------------------|
| %s       | any object                   |
| %d       | integers                     |
| %f       | numbers (fixed point format) |
| %e       | numbers (scientific format)  |

Between the % sign and the letter some combination of digits and symbols can
modify the output; here are some example: please refer to a printf manual for
more details

#+begin_src python :eval never-export :results output :exports both
print("|%10s| and |%-10s| space padding" % ("positive", "negative"))
print("fixed point %.4f and scientific %.4e modifiers" % (3.14159, 3.14159 / 1000))
#+end_src

#+RESULTS:
: |  positive| and |negative  | space padding
: fixed point 3.1416 and scientific 3.1416e-03 modifiers

*  Dictionaries and Sets (and more Strings)
**  Set iterals
Sets are containers which behave as math sets:
- they contain just one copy of each value
- it is possible to efficiently test if a value belongs to the sets
more operations on set will be described later

Set literal constructor is the curl brace.

#+begin_src python :eval never-export :results output :exports both
{} # an empty set
{"Hi"} # a set with only one item
print({2,2,3,1,"Joe"}) # duplicate item in literals will be dropped
#+end_src

#+RESULTS:
: {1, 2, 3, 'Joe'}

lists are not allowed to be set values while tuples are. This is related to
their immutability as we will see later
**  Dictionary literals
dictionaries or maps associate keys with values.

As their literal constructor is a list of key-value pairs; each pair is divided
by a colon and the list is surrounded by curl braces

As with other containers there is no restriction to use different types of
objects in the same container.

Lists are not valid keys while tuples are (as with set contents).

#+begin_src python :eval never-export :results output :exports both
{"hello":1, 10:True, (1,2,3,4):3.14159}
#+end_src
**  Dictionary access
to retrieve a value from a dictionary, its key can be passed through the square
bracket operator

#+begin_src python :eval never-export :results output :exports both
print({"hello":1, 10:True, (1,2,3,4):3.14159}["hello"])
#+end_src

#+RESULTS:
: 1

if the selected key is missing an error is generated
**  Set and dictionary operators
the ~in~ operator can check if an element is part of a set or if there is a key
in a dictionary

#+begin_src python :eval never-export :results output :exports both
print(2 in {10, "Joe", 2})
print(2 in {"hello":1, 10:True, (1,2,3,4):3.14159})
#+end_src

#+RESULTS:
: True
: False

while this operator also works on tuples and lists its time complexity is linear
while it is constant on dictionaries and sets, so it is not recommended to use
it with them.
**  String formatting with modulo and dictionaries
Dictionaries can be used as the right operand in string formatting expressions
with the modulo operator.

This can be useful when
- formatting strings with many data without worrying about order
- rusing the same value multiple times

placeholders modifiers will include key names in parens
#+begin_src python :eval never-export :results output :exports both
print("on %(date)s the temperature is %(temperature).2f degrees" % {"temperature":2.3, "date":"Monday, January 1st"})
print("My name is %(surname)s, %(first name)s %(surname)s" % {"first name":"James", "surname":"Bond"})
#+end_src

#+RESULTS:
: on Monday, January 1st the temperature is 2.30 degree
: My name is Bond, James Bond
